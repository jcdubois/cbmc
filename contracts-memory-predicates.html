<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: Memory Predicates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('contracts-memory-predicates.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Memory Predicates</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md114">The __CPROVER_pointer_equals predicate</a></li>
<li class="level1"><a href="#autotoc_md115">The __CPROVER_is_fresh predicate</a></li>
<li class="level1"><a href="#autotoc_md116">The __CPROVER_pointer_in_range_dfcc predicate</a><ul><li class="level2"><a href="#autotoc_md117">Syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md118">Using memory predicates in disjunctions</a></li>
<li class="level1"><a href="#autotoc_md119">Writing your own memory predicates</a><ul><li class="level2"><a href="#autotoc_md120">Limitations</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md121">Additional Resources</a></li>
</ul>
</div>
<div class="textblock"><p>Back to <a class="el" href="contracts-user.html">Code Contracts User Documentation</a></p>
<p>The built-in predicates discussed in this section are used to describe pointer properties in <em>requires clauses</em> and <em>ensures clauses</em>.</p>
<p>At a basic level the predicates allow to specify pointers to fresh objects (i.e. allocated and distinct, <code>__CPROVER_is_fresh(p, size)</code>), of aliased pointers (<code>__CPROVER_pointer_equals(p, q)</code>), or pointers ranging over pointer intervals (<code>__CPROVER_pointer_in_range_dfcc(lb, p, ub)</code>).</p>
<p>They can only be used in the context of a requires and ensures clauses, any attempt to call these predicates outside of a requires or ensures clause will result in a verification error.</p>
<p>Pointer predicates can be used with conjunctions, implications or disjunctions to describe richer data structures where some parts are only conditionally allocated, but requires and ensures clauses must not attempt to establish more than one predicate at the same time for a same pointer.</p>
<p>One can build their own pointer predicates using these built-in predicates, to describe (bounded) linked data structures such as buffers, lists, etc.</p>
<h1><a class="anchor" id="autotoc_md114"></a>
The __CPROVER_pointer_equals predicate</h1>
<p>This predicate checks for pointer validity and equality.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="cprover__builtin__headers_8h.html#ac61fb50d2ca904c50381ed220caa1c72">__CPROVER_pointer_equals</a>(<span class="keywordtype">void</span> *p, <span class="keywordtype">void</span> *<a class="code hl_class" href="classait.html">q</a>);</div>
<div class="ttc" id="aclassait_html"><div class="ttname"><a href="classait.html">ait</a></div><div class="ttdoc">ait supplies three of the four components needed: an abstract interpreter (in this case handling func...</div><div class="ttdef"><b>Definition</b> <a href="ai_8h_source.html#l00561">ai.h:562</a></div></div>
<div class="ttc" id="acprover__builtin__headers_8h_html_ac61fb50d2ca904c50381ed220caa1c72"><div class="ttname"><a href="cprover__builtin__headers_8h.html#ac61fb50d2ca904c50381ed220caa1c72">__CPROVER_pointer_equals</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_pointer_equals(void *p, void *q)</div></div>
</div><!-- fragment --><p>This predicate checks for pointer validity and equality.</p>
<p>It returns:</p><ul>
<li><code>true</code> if and only if:<ul>
<li><code>p</code> is either <code>NULL</code> or valid,</li>
<li><code>q</code> is either <code>NULL</code> of valid,</li>
<li><code>p</code> is equal to <code>q</code>.</li>
</ul>
</li>
</ul>
<p>When checking a function against a contract (<code>--enforce-contract</code>):</p><ul>
<li>in a <em>requires</em> clause, the predicate will check that <code>q</code> is always either <code>NULL</code> or valid, and it will assign <code>p</code> with <code>q</code>. This results in a state where both pointers are either <code>NULL</code> or valid and are equal;</li>
<li>used in an <em>ensures</em> clause it will check that both <code>p</code> and <code>q</code> are either NULL or valid, and that <code>p == q</code>.</li>
</ul>
<p>When replacing a function call by a contract (<code>--replace-call-with-contract</code>): we get the dual behaviour:</p><ul>
<li>used in a <em>requires</em> clause it will check that both <code>p</code> and <code>q</code> are either NULL or valid, and that <code>p == q</code>.</li>
<li>in an _ensures clause, the predicate will check that <code>q</code> is always either <code>NULL</code> or valid, and it will assign <code>p</code> with <code>q</code>. This results in a state where both pointers are either <code>NULL</code> or valid and are equal;</li>
</ul>
<h1><a class="anchor" id="autotoc_md115"></a>
The __CPROVER_is_fresh predicate</h1>
<p>The predicate <code>__CPROVER_is_fresh</code> takes a pointer <code>p</code> and an allocation size <code>size</code> and checks pointer validity and separation with other fresh pointers.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<span class="keywordtype">void</span> *p, <span class="keywordtype">size_t</span> size);</div>
<div class="ttc" id="acprover__builtin__headers_8h_html_ad4e9673ed79a6d8ff4af6cf12d95c29f"><div class="ttname"><a href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_is_fresh(const void *mem, __CPROVER_size_t size)</div></div>
</div><!-- fragment --><p>The predicate <code>__CPROVER_is_fresh(p, n)</code> holds when <code>p</code> points into a valid object with at least <code>n</code> bytes available after the pointer, and the object pointed to by <code>p</code> is distinct from all other objects pointed to in other <code>__CPROVER_is_fresh(q, m)</code> found in the requires and ensures clauses.</p>
<p>When checking a function against a contract (<code>--enforce-contract</code>):</p><ul>
<li><code>__CPROVER_is_fresh</code> in the <code>requires</code> clause works like a nondeterministic <code>p = malloc(size)</code> (separation is assured by construction);</li>
<li><code>__CPROVER_is_fresh</code> in the <code>ensures</code> clause checks pointer validity and separation against other <code>__CPROVER_is_fresh</code> occurrences in the <code>requires</code> clause and the <code>ensures</code> clause.</li>
</ul>
<p>When replacing a function call by a contract (<code>--replace-call-with-contract</code>):</p><ul>
<li><code>__CPROVER_is_fresh</code> in the <code>requires</code> clause checks pointer validity and separation against other <code>__CPROVER_is_fresh</code> occurrences in the <code>requires</code> clause;</li>
<li><code>__CPROVER_is_fresh</code> in the <code>ensures</code> clause works like a nondeterministic <code>p = malloc(size)</code> (separation is assured by construction);</li>
</ul>
<h1><a class="anchor" id="autotoc_md116"></a>
The __CPROVER_pointer_in_range_dfcc predicate</h1>
<h2><a class="anchor" id="autotoc_md117"></a>
Syntax</h2>
<p>This predicate holds if pointers <code>lb</code>, <code>p</code> and <code>ub</code> are valid pointers, pointing within the same object and the condition <code>lb &lt;= p &amp;&amp; p &lt;= ub</code> holds.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="cprover__builtin__headers_8h.html#a33926c3f831d23353ac2baf02eeb063a">__CPROVER_pointer_in_range_dfcc</a>(<span class="keywordtype">void</span> *lb, <span class="keywordtype">void</span> *p, <span class="keywordtype">void</span> *ub);</div>
<div class="ttc" id="acprover__builtin__headers_8h_html_a33926c3f831d23353ac2baf02eeb063a"><div class="ttname"><a href="cprover__builtin__headers_8h.html#a33926c3f831d23353ac2baf02eeb063a">__CPROVER_pointer_in_range_dfcc</a></div><div class="ttdeci">__CPROVER_bool __CPROVER_pointer_in_range_dfcc(void *lb, void *ptr, void *ub)</div></div>
</div><!-- fragment --><p>When checking a function against a contract (<code>--enforce-contract</code>):</p><ul>
<li>In the <code>requires</code> clause, <code>__CPROVER_pointer_in_range_dfcc</code> checks that <code>lb</code> and <code>ub</code> are valid and point into the same object, and nondeterministically assigns <code>p</code> to a nondet pointer between <code>lb</code> and <code>ub</code>;</li>
<li>In the <code>ensures</code> clause, <code>__CPROVER_pointer_in_range_dfcc</code> checks that <code>lb</code> and <code>ub</code> are valid and point into the same object, that <code>p</code> is between <code>lb</code> and <code>ub</code>;</li>
</ul>
<p>When replacing a function call by a contract (<code>--replace-call-with-contract</code>):</p><ul>
<li>In the <code>requires</code> clause, <code>__CPROVER_pointer_in_range_dfcc</code> checks that <code>lb</code> and <code>ub</code> are valid and point into the same object, that <code>p</code> is between <code>lb</code> and <code>ub</code>;</li>
<li>In the <code>ensures</code> clause, <code>__CPROVER_pointer_in_range_dfcc</code> checks that <code>lb</code> and <code>ub</code> are valid and point into the same object, and nondeterministically assigns <code>p</code> to a nondet pointer between <code>lb</code> and <code>ub</code>;</li>
</ul>
<h1><a class="anchor" id="autotoc_md118"></a>
Using memory predicates in disjunctions</h1>
<p>It is possible to use memory predicates in disjunctions to describe alternatives.</p>
<p>For instance, to specify a conditionally allocated pointer, the implication <code>==&gt;</code> operator can be used.</p>
<p>The <code>array</code> pointer is only valid when len is in some bounds, otherwise nothing is assumed about <code>array</code> and the pointer is considered <em>invalid</em>, i.e. any attempt to use it by the program under verification will result in an error.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_class" href="classait.html">foo</a>(<span class="keywordtype">int</span> *array, <span class="keywordtype">size_t</span> len)</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(</div>
<div class="line">  (len &lt; <a class="code hl_class" href="classait.html">INT_MAX</a>/<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) &amp;&amp; len &gt; 0)</div>
<div class="line">      ==&gt; <a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(array, len*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)))</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>In this other example, the function takes two pointers <code>a</code> and <code>b</code> and a and sets <code>*out</code> to the longest one:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="classait.html">foo</a>(<span class="keywordtype">int</span> *<a class="code hl_class" href="classait.html">a</a>, <span class="keywordtype">size_t</span> <a class="code hl_class" href="classait.html">len_a</a>, <span class="keywordtype">int</span> *<a class="code hl_class" href="classait.html">b</a>, <span class="keywordtype">size_t</span> <a class="code hl_class" href="classait.html">len_b</a>, <span class="keywordtype">int</span> **out)</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<a class="code hl_class" href="classait.html">a</a>, <a class="code hl_class" href="classait.html">len_a</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)))</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<a class="code hl_class" href="classait.html">b</a>, <a class="code hl_class" href="classait.html">len_b</a> * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)))</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(out, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span> *)))</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_assigns</a>(*out)</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_class" href="classait.html">len_a</a> &gt;= <a class="code hl_class" href="classait.html">len_b</a> ==&gt; <a class="code hl_function" href="cprover__builtin__headers_8h.html#ac61fb50d2ca904c50381ed220caa1c72">__CPROVER_pointer_equals</a>(*out, <a class="code hl_class" href="classait.html">a</a>))</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_class" href="classait.html">len_a &lt; len_b ==&gt;</a> <a class="code hl_function" href="cprover__builtin__headers_8h.html#ac61fb50d2ca904c50381ed220caa1c72">__CPROVER_pointer_equals</a>(*out, <a class="code hl_class" href="classait.html">b</a>))</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>In last other example, the function takes two pointers <code>a</code> and <code>b</code> and a and sets <code>*out</code> to either <code>a</code> or <code>b</code>, nondeterministically:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="classait.html">foo</a>(<span class="keywordtype">int</span> *<a class="code hl_class" href="classait.html">a</a>, <span class="keywordtype">int</span> *<a class="code hl_class" href="classait.html">b</a>, <span class="keywordtype">int</span> **out)</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<a class="code hl_class" href="classait.html">a</a>, 1)) <span class="comment">// at least one byte</span></div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<a class="code hl_class" href="classait.html">b</a>, 1))</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(out, <a class="code hl_class" href="classait.html">sizeof</a>(<span class="keywordtype">int</span> *)))</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_assigns</a>(*out)</div>
<div class="line"><a class="code hl_class" href="classait.html">__CPROVER_requires</a>(</div>
<div class="line">  <a class="code hl_function" href="cprover__builtin__headers_8h.html#ac61fb50d2ca904c50381ed220caa1c72">__CPROVER_pointer_equals</a>(*out, <a class="code hl_class" href="classait.html">a</a>) || <a class="code hl_function" href="cprover__builtin__headers_8h.html#ac61fb50d2ca904c50381ed220caa1c72">__CPROVER_pointer_equals</a>(*out, <a class="code hl_class" href="classait.html">b</a>))</div>
<div class="line">{</div>
<div class="line">   ...</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md119"></a>
Writing your own memory predicates</h1>
<p>One can write their own memory predicates based on the built-in predicates.</p>
<p>One can specify (finite) nested structures:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_class" href="classait.html">buffer_t</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">size_t</span> size;</div>
<div class="line">  <span class="keywordtype">char</span> *<a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">arr</a>;</div>
<div class="line">  <span class="keywordtype">char</span> *<a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">cursor</a>;</div>
<div class="line">} <a class="code hl_class" href="classait.html">buffer_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_class" href="classait.html">double_buffer_t</a></div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classait.html">buffer_t</a> *first;</div>
<div class="line">  <a class="code hl_class" href="classait.html">buffer_t</a> *second;</div>
<div class="line">} <a class="code hl_class" href="classait.html">double_buffer_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_class" href="classait.html">is_sized_array</a>(<span class="keywordtype">char</span> *<a class="code hl_class" href="classait.html">arr</a>, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<a class="code hl_class" href="classait.html">arr</a>, size);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_class" href="classait.html">is_buffer</a>(<a class="code hl_class" href="classait.html">buffer_t</a> *<a class="code hl_class" href="classait.html">b</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<a class="code hl_class" href="classait.html">b</a>, <span class="keyword">sizeof</span>(*<a class="code hl_class" href="classait.html">b</a>)) &amp;&amp; (0 &lt; <a class="code hl_class" href="classait.html">b</a>-&gt;size &amp;&amp; <a class="code hl_class" href="classait.html">b</a>-&gt;size &lt;= 10) &amp;&amp;</div>
<div class="line">         <a class="code hl_class" href="classait.html">is_sized_array</a>(<a class="code hl_class" href="classait.html">b</a>-&gt;arr, <a class="code hl_class" href="classait.html">b</a>-&gt;size) &amp;&amp;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_class" href="classait.html">is_double_buffer</a>(<a class="code hl_class" href="classait.html">double_buffer_t</a> *<a class="code hl_class" href="classait.html">b</a>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(<a class="code hl_class" href="classait.html">b</a>, <span class="keyword">sizeof</span>(*<a class="code hl_class" href="classait.html">b</a>)) &amp;&amp; <a class="code hl_class" href="classait.html">is_buffer</a>(<a class="code hl_class" href="classait.html">b</a>-&gt;first) &amp;&amp;</div>
<div class="line">         <a class="code hl_class" href="classait.html">is_buffer</a>(<a class="code hl_class" href="classait.html">b</a>-&gt;second);</div>
<div class="line">}</div>
<div class="ttc" id="aclassait_html_acb910a3c8ab35d67a9a9a27c324e4992"><div class="ttname"><a href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">ait::ait</a></div><div class="ttdeci">ait()</div><div class="ttdef"><b>Definition</b> <a href="ai_8h_source.html#l00565">ai.h:565</a></div></div>
</div><!-- fragment --><p>One can even describe inductively defined (but bounded) structures such as lists:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_class" href="classait.html">list_t</a></div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> value;</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_class" href="classait.html">list_t</a> *next;</div>
<div class="line">} <a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">list_t</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">value_in_range</a>(<span class="keywordtype">int</span> lb, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> ub) {</div>
<div class="line">  <span class="keywordflow">return</span> lb &lt;= value &amp;&amp; value &lt;= ub;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">is_list</a>(<a class="code hl_class" href="classait.html">list_t</a> *l, <span class="keywordtype">size_t</span> len)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(len == 0) {</div>
<div class="line">    <span class="comment">// list size bounded by `len`</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="cprover__builtin__headers_8h.html#ac61fb50d2ca904c50381ed220caa1c72">__CPROVER_pointer_equals</a>(l,  <a class="code hl_class" href="classait.html">NULL</a>);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// either NULL or some fresh node</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="cprover__builtin__headers_8h.html#ac61fb50d2ca904c50381ed220caa1c72">__CPROVER_pointer_equals</a>(l,  <a class="code hl_class" href="classait.html">NULL</a>)) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code hl_function" href="cprover__builtin__headers_8h.html#ad4e9673ed79a6d8ff4af6cf12d95c29f">__CPROVER_is_fresh</a>(l, <span class="keyword">sizeof</span>(*l)) &amp;&amp;</div>
<div class="line">        <a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">value_in_range</a>(-10, l-&gt;value, 10) &amp;&amp;</div>
<div class="line">        <a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">is_list</a>(l-&gt;next, len - 1);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>And use these predicates in requires/ensures clauses:</p>
<div class="fragment"><div class="line"><span class="comment">// take a list and a double buffer and sum list values and buffer sizes</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">foo</a>(<a class="code hl_class" href="classait.html">list_t</a> *l, <a class="code hl_class" href="classait.html">double_buffer_t</a> *<a class="code hl_class" href="classait.html">b</a>)</div>
<div class="line">  <span class="comment">// clang-format off</span></div>
<div class="line">  <a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">__CPROVER_requires</a>(<a class="code hl_function" href="classait.html#acb910a3c8ab35d67a9a9a27c324e4992">is_list</a>(l, 3))</div>
<div class="line">  <a class="code hl_class" href="classait.html">__CPROVER_requires</a>(<a class="code hl_class" href="classait.html">is_double_buffer</a>(<a class="code hl_class" href="classait.html">b</a>))</div>
<div class="line">  <a class="code hl_class" href="classait.html">__CPROVER_ensures</a>(-28 &lt;= <a class="code hl_class" href="classait.html">__CPROVER_return_value</a> &amp;&amp; <a class="code hl_class" href="classait.html">__CPROVER_return_value</a> &lt;= 50)</div>
<div class="line"><span class="comment">// clang-format on</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// access the assumed data structure</span></div>
<div class="line">  <span class="keywordflow">return</span> l-&gt;value + l-&gt;next-&gt;value + l-&gt;next-&gt;next-&gt;value + <a class="code hl_class" href="classait.html">b</a>-&gt;first-&gt;size +</div>
<div class="line">         <a class="code hl_class" href="classait.html">b</a>-&gt;second-&gt;size;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Internally, CBMC instruments these user-defined predicates to turn them into</p><ul>
<li>nondeterministic allocators that build the data structures when used in assumption contexts;</li>
<li>checker functions that can walk a pointer structure and check pointer validity and separation/aliasing/interval constraints in assertion contexts.</li>
</ul>
<h2><a class="anchor" id="autotoc_md120"></a>
Limitations</h2>
<p>The main limitation with user defined predicates are:</p><ul>
<li>their evaluation must terminate;<ul>
<li>For instance, in the <code>is_list</code> example above, recursion is bounded using use of the explicit <code>len</code> parameter.</li>
<li>The <code>is_double_buffer</code> predicate also describes a bounded structure.</li>
</ul>
</li>
<li>mutually-recursive predicates are not supported for the moment.</li>
</ul>
<h1><a class="anchor" id="autotoc_md121"></a>
Additional Resources</h1>
<ul>
<li><a class="el" href="contracts-functions.html">Function Contracts</a><ul>
<li><a class="el" href="contracts-requires-ensures.html">Requires and Ensures Clauses</a></li>
<li><a class="el" href="contracts-assigns.html">Assigns Clauses</a></li>
<li><a class="el" href="contracts-frees.html">Frees Clauses</a></li>
</ul>
</li>
<li><a class="el" href="contracts-loops.html">Loop Contracts</a><ul>
<li><a class="el" href="contracts-loop-invariants.html">Loop Invariant Clauses</a></li>
<li><a class="el" href="contracts-decreases.html">Decreases Clauses</a></li>
<li><a class="el" href="contracts-assigns.html">Assigns Clauses</a></li>
<li><a class="el" href="contracts-frees.html">Frees Clauses</a></li>
</ul>
</li>
<li><a class="el" href="contracts-memory-predicates.html">Memory Predicates</a></li>
<li><a class="el" href="contracts-function-pointer-predicates.html">Function Pointer Predicates</a></li>
<li><a class="el" href="contracts-history-variables.html">History Variables</a></li>
<li><a class="el" href="contracts-quantifiers.html">Quantifiers</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="contracts-mainpage.html">Code Contracts in CBMC</a></li><li class="navelem"><a class="el" href="contracts-user.html">Code Contracts User Documentation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
